#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Archivo: analizar_restaurantes.py
DescripciÃ³n: Hereda de DatabaseManager para obtener los links de restaurantes no completos,
y utiliza Selenium para extraer informaciÃ³n de cada restaurante, gestionando previamente
los modales que puedan aparecer.
"""

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from webdriver_manager.chrome import ChromeDriverManager
import time
import mysql.connector
from bbdd import DatabaseManager  # AsegÃºrate de que la ruta y el nombre sean correctos

# Extendemos la clase DatabaseManager (esto es opcional, tambiÃ©n podrÃ­as instanciar DatabaseManager directamente)
class ExtendedDatabaseManager(DatabaseManager):
    # AquÃ­ ya tendrÃ¡s disponible el mÃ©todo obtener_links_no_completos() aÃ±adido previamente
    pass

# Instanciamos la clase de base de datos
db_manager = ExtendedDatabaseManager(
    host="localhost",
    user="root",
    password="collado",
    database="restaurantes_db"
)

# Obtenemos la lista de links de restaurantes con 'completo' = 0
urls = db_manager.obtener_links_no_completos()

print("ğŸ”— Links de restaurantes incompletos obtenidos desde la base de datos:")
for link in urls:
    print(link)

# DefiniciÃ³n de la clase Restaurante (puedes adaptarla segÃºn tus necesidades)
class Restaurante:
    def __init__(self, url, nombre, localizacion, estrellas):
        self.url = url
        self.nombre = nombre
        self.localizacion = (
            localizacion if localizacion and localizacion.lower() != "none" else "UbicaciÃ³n desconocida"
        )
        self.estrellas = estrellas

    def __repr__(self):
        return f"{self.nombre} ({self.estrellas}â­) - {self.localizacion}\n{self.url}\n"

# ConfiguraciÃ³n de Selenium WebDriver
chrome_options = Options()
chrome_options.add_argument("--disable-blink-features=AutomationControlled")
chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
chrome_options.add_experimental_option("useAutomationExtension", False)

service = Service(ChromeDriverManager().install())
driver = webdriver.Chrome(service=service, options=chrome_options)

restaurantes = []

try:
    for url in urls:
        driver.get(url)
        time.sleep(0.5)  # Ajusta el tiempo de espera segÃºn la velocidad de carga

        # Comprobamos si aparece un modal (buscamos por el selector del contenedor modal)
        modals = driver.find_elements(By.CSS_SELECTOR, "div.ReactModal__Content.modal")
        if modals:
            modal = modals[0]
            try:
                # Pulsar en el botÃ³n de cerrar (asegÃºrate de que el selector coincida con el botÃ³n de close en tu modal)
                close_button = modal.find_element(By.XPATH, ".//button[contains(@class, 'close')]")
                close_button.click()
                time.sleep(0.2)
            except Exception as e:
                print("âŒ Error al pulsar el botÃ³n de cerrar el modal:", e)
            # Recargar la URL despuÃ©s de cerrar el modal
            driver.get(url)
            time.sleep(0.5)

        # Extraemos la informaciÃ³n del restaurante
        try:
            nombre = driver.find_element(By.CSS_SELECTOR, "div.restaurant-header-style_info__XsFU1 h1").text
        except:
            nombre = "Nombre no encontrado"
        
        try:
            estrellas = driver.find_element(By.CSS_SELECTOR, "div[data-qa='restaurant-header-score'] b").text
        except:
            estrellas = "0"
        
        try:
            colophon = driver.find_elements(By.CSS_SELECTOR, "div.colophon-style_row__tBLCx div[data-qa='text']")
            if len(colophon) >= 3:
                direccion = f"{colophon[1].text}, {colophon[2].text}"
            else:
                direccion = "UbicaciÃ³n no disponible"
        except:
            direccion = "UbicaciÃ³n no encontrada"

        # Crear objeto Restaurante
        restaurante = Restaurante(url, nombre, direccion, estrellas)
        restaurantes.append(restaurante)
        print(restaurante)
finally:
    driver.quit()
    db_manager.cerrar()

# Mostrar resultados obtenidos por Selenium
print("\nğŸ“‹ Resultados del anÃ¡lisis de cada restaurante:")
for restaurante in restaurantes:
    restaurante.__repr__()
